/// <reference types='@vechain/connex-types'/>
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Provider = void 0;
const utils_1 = require("./utils");
const error_1 = require("./error");
const formatter_1 = require("./formatter");
const thor_devkit_1 = require("thor-devkit");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const restful_1 = require("./restful");
const eip1193_1 = require("./eip1193");
const common_1 = require("./common");
const web3_utils_1 = require("web3-utils");
class Provider extends eventemitter3_1.default {
    constructor(opt) {
        super();
        this._methodMap = {};
        this._subscriptions = {
            newHeads: {},
            logs: {},
        };
        this._getTransactionIndex = (blkId, txId) => __awaiter(this, void 0, void 0, function* () {
            const blk = yield this.connex.thor.block(blkId).get();
            if (!blk) {
                return Promise.reject(new Error(`Block ${blkId} not found`));
            }
            const txIndex = blk.transactions.findIndex(elem => elem == txId);
            if (txIndex == -1) {
                return Promise.reject(new Error(`Tx ${txId} not found in block`));
            }
            return txIndex;
        });
        this._getNumOfLogsAhead = (blkId, txId) => __awaiter(this, void 0, void 0, function* () {
            const blk = yield this.connex.thor.block(blkId).get();
            if (!blk) {
                return Promise.reject(new Error(`Block ${blkId} not found`));
            }
            const txInd = yield this._getTransactionIndex(blkId, txId);
            // Count the number of logs in the txs whose number is lower than txId
            let logInd = 0;
            for (let i = 0; i < txInd; i++) {
                const txId = blk.transactions[i];
                const receipt = yield this.connex.thor.transaction(txId).getReceipt();
                if (!receipt) {
                    return Promise.reject(new Error(`Receipt of Tx ${txId} not found`));
                }
                receipt.outputs.forEach(output => {
                    logInd += output.events.length;
                });
            }
            return logInd;
        });
        this._getLogIndexWithinTx = (log) => __awaiter(this, void 0, void 0, function* () {
            const receipt = yield this.connex.thor.transaction(log.meta.txID).getReceipt();
            if (!receipt) {
                return Promise.reject(new Error(`Receipt of Tx ${log.meta.txID}} not found`));
            }
            let offset = 0;
            for (let output of receipt.outputs) {
                const events = output.events;
                for (let i = 0; i < events.length; i++) {
                    const ev = events[i];
                    if (log.address !== ev.address
                        || log.topics.length !== ev.topics.length
                        || log.data !== ev.data) {
                        continue;
                    }
                    for (let j = 0; j < log.topics.length; j++) {
                        if (log.topics[j] !== ev.topics[j]) {
                            continue;
                        }
                    }
                    return i + offset;
                }
                offset += events.length;
            }
            return Promise.reject(new Error('Log not found'));
        });
        this._mine = (_) => __awaiter(this, void 0, void 0, function* () {
            yield this.connex.thor.ticker().next();
        });
        this._accounts = (_) => __awaiter(this, void 0, void 0, function* () {
            if (!this.wallet || this.wallet.list.length === 0) {
                return [];
            }
            return this.wallet.list.map(key => key.address);
        });
        this._sendRawTransaction = (params) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.restful) {
                    return yield this.restful.sendRawTransaction(params[0]);
                }
            }
            catch (err) {
                if (err instanceof eip1193_1.ProviderRpcError) {
                    return Promise.reject(err);
                }
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, (0, utils_1.getErrMsg)(err)));
            }
            return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, 'Restful API not supported'));
        });
        this._subscribe = (params) => __awaiter(this, void 0, void 0, function* () {
            const subId = this._getSubscriptionId(params);
            const subName = params[0];
            this._subscriptions[subName][subId] = params[1] || {};
            return subId;
        });
        this._unsubscribe = (params) => __awaiter(this, void 0, void 0, function* () {
            const subId = params[0];
            if (!this._subscriptions['newHeads'][subId] && !this._subscriptions['logs'][subId]) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, error_1.ErrMsg.SubscriptionIdNotFound(subId)));
            }
            this._subscriptions['newHeads'][subId] ?
                delete this._subscriptions['newHeads'][subId] :
                delete this._subscriptions['logs'][subId];
            return true;
        });
        this._subLoop = () => __awaiter(this, void 0, void 0, function* () {
            const ticker = this.connex.thor.ticker();
            try {
                for (;;) {
                    const best = yield ticker.next();
                    const newHeadsKeys = Object.keys(this._subscriptions['newHeads']);
                    if (newHeadsKeys.length > 0) {
                        const blk = yield this.connex.thor.block().get();
                        if (blk) {
                            newHeadsKeys.forEach(key => {
                                this.emit('message', (0, utils_1.toSubscription)(this._formatter.outputHeaderFormatter(blk), key));
                            });
                        }
                    }
                    const logsKeys = Object.keys(this._subscriptions['logs']);
                    if (logsKeys.length > 0) {
                        yield Promise.all(logsKeys.map((key) => __awaiter(this, void 0, void 0, function* () {
                            const MAX_LIMIT = 256;
                            const range = {
                                unit: 'block',
                                from: best.number,
                                to: best.number,
                            };
                            let logs = yield this.connex.thor.filter('event', this._subscriptions['logs'][key])
                                .range(range)
                                .apply(0, MAX_LIMIT);
                            if (logs) {
                                const txInds = [];
                                const logInds = [];
                                for (let i = 0; i < logs.length; i++) {
                                    const log = logs[i];
                                    const offset = yield this._getNumOfLogsAhead(log.meta.blockID, log.meta.txID);
                                    const ind = yield this._getLogIndexWithinTx(log);
                                    logInds[i] = (0, web3_utils_1.numberToHex)(offset + ind);
                                    txInds[i] = (0, web3_utils_1.numberToHex)(yield this._getTransactionIndex(log.meta.blockID, log.meta.txID));
                                }
                                ;
                                this.emit('message', (0, utils_1.toSubscription)(this._formatter.outputLogsFormatter({ logs: logs, txInds: txInds, logInds: logInds }), key));
                            }
                        })));
                    }
                }
            }
            catch (err) {
                throw new Error(err);
            }
        });
        this._getSubscriptionId = (params) => {
            return '0x' + (0, thor_devkit_1.keccak256)((new Date()).getTime().toString(), JSON.stringify(params)).toString('hex');
        };
        this._getLogs = (params) => __awaiter(this, void 0, void 0, function* () {
            const MAX_LIMIT = 256;
            const opts = params[0];
            try {
                let logs = yield this.connex.thor.filter('event', opts.criteria)
                    .range(opts.range)
                    .apply(0, MAX_LIMIT);
                if (logs.length === 0) {
                    return [];
                }
                const txInds = [];
                const logInds = [];
                for (let i = 0; i < logs.length; i++) {
                    const log = logs[i];
                    const offset = yield this._getNumOfLogsAhead(log.meta.blockID, log.meta.txID);
                    const ind = yield this._getLogIndexWithinTx(log);
                    logInds[i] = (0, web3_utils_1.numberToHex)(offset + ind);
                    txInds[i] = (0, web3_utils_1.numberToHex)(yield this._getTransactionIndex(log.meta.blockID, log.meta.txID));
                }
                return this._formatter.outputLogsFormatter({ logs: logs, txInds: txInds, logInds: logInds });
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._estimateGas = (params) => __awaiter(this, void 0, void 0, function* () {
            const txObj = params[0];
            let explainer = this.connex.thor.explain([txObj.clauses[0]]);
            if (txObj.caller) {
                explainer = explainer.caller(txObj.caller);
            }
            if (txObj.gas) {
                explainer = explainer.gas(txObj.gas);
            }
            try {
                const outputs = yield explainer.execute();
                const output = outputs[0];
                if (output.reverted) {
                    if (output.vmError === 'execution reverted' && output.revertReason) {
                        return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, `execution reverted: ${output.revertReason}`, output.data));
                    }
                    else {
                        return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, output.vmError));
                    }
                }
                const clause = {
                    to: txObj.clauses[0].to,
                    value: txObj.clauses[0].value,
                    data: txObj.clauses[0].data ? txObj.clauses[0].data : '0x',
                };
                const execGas = outputs.reduce((sum, out) => sum + out.gasUsed, 0);
                const intrinsicGas = thor_devkit_1.Transaction.intrinsicGas([clause]);
                const estimatedGas = intrinsicGas + (execGas ? (execGas + 15000) : 0);
                return (0, utils_1.toHex)(estimatedGas);
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._call = (params) => __awaiter(this, void 0, void 0, function* () {
            const txObj = params[0];
            try {
                if (this.restful) {
                    return yield this.restful.call(txObj, params[1]);
                }
                let explainer = this.connex.thor.explain([txObj.clauses[0]]);
                if (txObj.caller) {
                    explainer = explainer.caller(txObj.caller);
                }
                if (txObj.gas) {
                    explainer = explainer.gas(txObj.gas);
                }
                const outputs = yield explainer.execute();
                const output = outputs[0];
                if (output.reverted) {
                    if (output.vmError === 'execution reverted' && output.revertReason) {
                        return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, `execution reverted: ${output.revertReason}`, output.data));
                    }
                    else {
                        return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, output.vmError));
                    }
                }
                return output.data;
            }
            catch (err) {
                if (err instanceof eip1193_1.ProviderRpcError) {
                    return Promise.reject(err);
                }
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._sendTransaction = (params) => __awaiter(this, void 0, void 0, function* () {
            const txObj = params[0];
            let ss = this.connex.vendor.sign('tx', [txObj.clauses[0]]);
            if (txObj.caller) {
                ss = ss.signer(txObj.caller);
            }
            if (this._delegate) {
                if (this._delegate.signer) {
                    ss = ss.delegate(this._delegate.url, this._delegate.signer);
                }
                else {
                    ss = ss.delegate(this._delegate.url);
                }
            }
            if (txObj.gas) {
                ss = ss.gas(txObj.gas);
            }
            try {
                const ret = yield ss.request();
                return ret.txid;
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._getStorageAt = (params) => __awaiter(this, void 0, void 0, function* () {
            const [addr, key, revision] = params;
            try {
                if (this.restful) {
                    return yield this.restful.getStorageAt(addr, key, revision);
                }
                const storage = yield this.connex.thor.account(addr).getStorage(key);
                return storage.value;
            }
            catch (err) {
                if (err instanceof eip1193_1.ProviderRpcError) {
                    return Promise.reject(err);
                }
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._getTransactionReceipt = (params) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const hash = params[0];
            try {
                const receipt = yield this.connex.thor.transaction(hash).getReceipt();
                if (!receipt) {
                    return null;
                }
                else {
                    const blkId = receipt.meta.blockID;
                    const blk = yield this.connex.thor.block(blkId).get();
                    if (!blk) {
                        return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, 'Block not found'));
                    }
                    const tx = yield this.connex.thor.transaction(hash).get();
                    if (!tx) {
                        return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.Default, 'Tx not found'));
                    }
                    const txInd = (0, web3_utils_1.numberToHex)(yield this._getTransactionIndex(blkId, hash));
                    const logIndOffset = yield this._getNumOfLogsAhead(blkId, hash);
                    const n = ((_a = receipt.outputs[0]) === null || _a === void 0 ? void 0 : _a.events.length) || 0;
                    const logInds = new Array(n)
                        .fill(logIndOffset)
                        .map((_, i) => { return (0, web3_utils_1.numberToHex)(logIndOffset + i); });
                    return this._formatter.outputReceiptFormatter(Object.assign(Object.assign({}, receipt), {
                        transactionIndex: txInd,
                        logInds: logInds,
                        from: tx.origin,
                        to: tx.clauses[0].to
                    }));
                }
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
            ;
        });
        this._isSyncing = (_) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.connex.thor.ticker().next();
                if (this.connex.thor.status.progress == 1) {
                    return false;
                }
                else {
                    const highestBlock = Math.floor((Date.now() - this.connex.thor.genesis.timestamp) / 10000);
                    return {
                        startingBlock: null,
                        currentBlock: (0, utils_1.toHex)(this.connex.thor.status.head.number),
                        highestBlock: (0, utils_1.toHex)(highestBlock),
                    };
                }
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._getCode = (params) => __awaiter(this, void 0, void 0, function* () {
            const [addr, revision] = params;
            try {
                if (this.restful) {
                    return yield this.restful.getCode(addr, revision);
                }
                const code = yield this.connex.thor.account(addr).getCode();
                return code.code;
            }
            catch (err) {
                if (err instanceof eip1193_1.ProviderRpcError) {
                    return Promise.reject(err);
                }
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._getBlockNumber = (_) => __awaiter(this, void 0, void 0, function* () {
            try {
                const blk = yield this.connex.thor.block().get();
                if (!blk) {
                    return null;
                }
                else {
                    return (0, utils_1.toHex)(blk.number);
                }
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._getBalance = (params) => __awaiter(this, void 0, void 0, function* () {
            const [addr, revision] = params;
            try {
                if (this.restful) {
                    return yield this.restful.getBalance(addr, revision);
                }
                const acc = yield this.connex.thor.account(addr).get();
                return acc.balance;
            }
            catch (err) {
                if (err instanceof eip1193_1.ProviderRpcError) {
                    return Promise.reject(err);
                }
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._getTransactionByHash = (params) => __awaiter(this, void 0, void 0, function* () {
            const hash = params[0];
            try {
                const tx = yield this.connex.thor.transaction(hash).get();
                if (!tx) {
                    return null;
                }
                else {
                    const ind = (0, web3_utils_1.numberToHex)(yield this._getTransactionIndex(tx.meta.blockID, hash));
                    return this._formatter.outputTransactionFormatter(Object.assign(Object.assign({}, tx), { transactionIndex: ind }));
                }
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._getChainId = (_) => __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.toHex)(this.chainTag);
        });
        this._getBlockByNumber = (params) => __awaiter(this, void 0, void 0, function* () {
            const num = params[0];
            try {
                const blk = yield this.connex.thor.block(num).get();
                if (!blk) {
                    return null;
                }
                else {
                    return this._formatter.outputBlockFormatter(blk);
                }
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this._getBlockByHash = (params) => __awaiter(this, void 0, void 0, function* () {
            const hash = params[0];
            try {
                const blk = yield this.connex.thor.block(hash).get();
                if (!blk) {
                    return null;
                }
                else {
                    return this._formatter.outputBlockFormatter(blk);
                }
            }
            catch (err) {
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.InternalError, (0, utils_1.getErrMsg)(err)));
            }
        });
        this.connex = opt.connex;
        const id = opt.connex.thor.genesis.id;
        this.chainTag = (0, utils_1.hexToNumber)('0x' + id.substring(id.length - 2));
        this._formatter = new formatter_1.Formatter(opt.connex, !!opt.net);
        this._delegate = opt.delegate || null;
        this._methodMap['eth_getBlockByHash'] = this._getBlockByHash;
        this._methodMap['eth_getBlockByNumber'] = this._getBlockByNumber;
        this._methodMap['eth_chainId'] = this._getChainId;
        this._methodMap['eth_getTransactionByHash'] = this._getTransactionByHash;
        this._methodMap['eth_getBalance'] = this._getBalance;
        this._methodMap['eth_blockNumber'] = this._getBlockNumber;
        this._methodMap['eth_getCode'] = this._getCode;
        this._methodMap['eth_syncing'] = this._isSyncing;
        this._methodMap['eth_getTransactionReceipt'] = this._getTransactionReceipt;
        this._methodMap['eth_getStorageAt'] = this._getStorageAt;
        this._methodMap['eth_sendTransaction'] = this._sendTransaction;
        this._methodMap['eth_call'] = this._call;
        this._methodMap['eth_estimateGas'] = this._estimateGas;
        this._methodMap['eth_getLogs'] = this._getLogs;
        this._methodMap['eth_subscribe'] = this._subscribe;
        this._methodMap['eth_unsubscribe'] = this._unsubscribe;
        this._methodMap['eth_accounts'] = this._accounts;
        this._methodMap['net_version'] = this._getChainId;
        if (opt.net) {
            this.restful = new restful_1.Restful(opt.net, this.connex.thor.genesis.id);
            this._methodMap['eth_sendRawTransaction'] = this._sendRawTransaction;
        }
        if (opt.wallet) {
            this.wallet = opt.wallet;
        }
        this._methodMap['web3_clientVersion'] = () => __awaiter(this, void 0, void 0, function* () { return "thor"; });
        // dummy
        this._methodMap['eth_gasPrice'] = () => __awaiter(this, void 0, void 0, function* () { return '0x0'; });
        this._methodMap['eth_getTransactionCount'] = () => __awaiter(this, void 0, void 0, function* () { return '0x0'; });
        this._subLoop();
        // Ganache methods
        this._methodMap['evm_mine'] = this._mine;
    }
    enableDelegate(opt) {
        const old = this._delegate;
        this._delegate = opt;
        return old;
    }
    disableDelegate() {
        const opt = this._delegate;
        this._delegate = null;
        return opt;
    }
    request(req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!common_1.EthJsonRpcMethods.includes(req.method)) {
                const msg = `Method ${req.method} not found`;
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.MethodNotFound, msg));
            }
            const exec = this._methodMap[req.method];
            if (!exec) {
                const msg = `Method ${req.method} not implemented`;
                return Promise.reject(new eip1193_1.ProviderRpcError(error_1.ErrCode.MethodNotFound, msg));
            }
            let params;
            try {
                params = this._formatter.formatInput(req.method, req.params);
            }
            catch (err) {
                return Promise.reject(err);
            }
            return exec(params);
        });
    }
}
exports.Provider = Provider;
//# sourceMappingURL=provider.js.map