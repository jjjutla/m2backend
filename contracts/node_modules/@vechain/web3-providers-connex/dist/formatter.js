'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Formatter = void 0;
const utils_1 = require("./utils");
const error_1 = require("./error");
const common_1 = require("./common");
const eip1193_1 = require("./eip1193");
class Formatter {
    constructor(connex, ifSetNet) {
        this._inputFormatters = {};
        this.formatInput = (method, params) => {
            const inputFormatter = this._inputFormatters[method];
            if (!inputFormatter) {
                return params || [];
            }
            if (!params) {
                const msg = 'Parameters missing';
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
            return inputFormatter(params);
        };
        this._getBlockByNumber = (params) => {
            const num = (0, utils_1.parseBlockNumber)(params[0]);
            if (num === null) {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getBlockByNumber', 'blockNumber');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
            return [num];
        };
        this._getBlockByHash = (params) => {
            const num = params[0];
            if (num !== (0, utils_1.parseBlockNumber)(num)) {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getBlockByNumber', 'blockHash');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
            return [num];
        };
        this._getBalance = (params) => {
            let [addr, revision = 'latest'] = params;
            if (!this._ifSetNet) {
                if (params.length == 2 &&
                    !(typeof revision === 'string' && revision === 'latest')) {
                    const msg = error_1.ErrMsg.MethodParamNotSupported('eth_getBalance', 2);
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
            }
            else if (typeof revision !== 'number') {
                revision = (0, utils_1.parseBlockNumber)(revision);
                if (revision === null) {
                    const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getBalance', 'revision');
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
            }
            return revision ? [addr, revision] : [addr];
        };
        this._getCode = (params) => {
            let [addr, revision = 'latest'] = params;
            if (!this._ifSetNet) {
                if (params.length >= 2 &&
                    !(typeof revision === 'string' && revision === 'latest')) {
                    const msg = error_1.ErrMsg.MethodParamNotSupported('eth_getCode', 2);
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
            }
            else if (typeof revision !== 'number') {
                revision = (0, utils_1.parseBlockNumber)(revision);
                if (revision === null) {
                    const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getCode', 'revision');
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
            }
            return revision ? [addr, revision] : [addr];
        };
        this._getStorageAt = (params) => {
            let [addr, key, revision = 'latest'] = params;
            if (!this._ifSetNet) {
                if (params.length >= 3 &&
                    !(typeof revision === 'string' && revision === 'latest')) {
                    const msg = error_1.ErrMsg.MethodParamNotSupported('eth_getStorageAt', 3);
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
            }
            else if (typeof revision !== 'number') {
                revision = (0, utils_1.parseBlockNumber)(revision);
                if (revision === null) {
                    const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getStorageAt', 'revision');
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
            }
            key = (0, utils_1.toBytes32)(key);
            return revision ? [addr, key, revision] : [addr, key];
        };
        this._sendTransaction = (params) => {
            const o1 = params[0];
            const o2 = {
                clauses: [{
                        to: o1.to || null,
                        value: !!o1.value ? (0, utils_1.toHex)(o1.value) : '0x0',
                        data: o1.data || '0x',
                    }],
                gas: !!o1.gas ? (0, utils_1.hexToNumber)(o1.gas) : undefined,
                caller: o1.from,
            };
            return [o2, params[1]];
        };
        this._call = (params) => {
            let [callObj, revision = 'latest'] = params;
            if (!this._ifSetNet) {
                if (params.length >= 2 &&
                    !(typeof revision === 'string' && revision === 'latest')) {
                    const msg = error_1.ErrMsg.MethodParamNotSupported('eth_call', 2);
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
            }
            else if (typeof revision !== 'number') {
                revision = (0, utils_1.parseBlockNumber)(revision);
                if (revision === null) {
                    const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_call', 'revision');
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
            }
            callObj = this._sendTransaction([callObj])[0];
            return revision ? [callObj, revision] : [callObj];
        };
        this._estimateGas = (params) => {
            return this._sendTransaction(params);
        };
        this._getLogs = (params) => {
            const args = params[0];
            let fromBlock, toBlock;
            if (!args.fromBlock) {
                fromBlock = this._connex.thor.status.head.number; // fromBlock default set to latest
            }
            else {
                let test = (0, utils_1.parseBlockNumber)(args.fromBlock);
                if (test === undefined) {
                    test = this._connex.thor.status.head.number;
                }
                else if (typeof test !== 'number') {
                    const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getLogs', 'options.fromBlock');
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
                fromBlock = test;
            }
            if (!args.toBlock) {
                toBlock = this._connex.thor.status.head.number; // toBlock default set to latest
            }
            else {
                let test = (0, utils_1.parseBlockNumber)(args.toBlock);
                if (test === undefined) {
                    test = this._connex.thor.status.head.number;
                }
                else if (typeof test !== 'number') {
                    const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_getLogs', 'options.toBlock');
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
                }
                toBlock = test;
                if (fromBlock > toBlock) {
                    fromBlock = toBlock;
                }
            }
            const out = {
                range: {
                    unit: 'block',
                    from: fromBlock,
                    to: toBlock,
                },
                criteria: (0, utils_1.toFilterCriteria)(args),
            };
            return [out];
        };
        this._subscribe = (params) => {
            const name = params[0];
            switch (name) {
                case 'newHeads':
                    return ['newHeads'];
                case 'logs':
                    return ['logs', (0, utils_1.toFilterCriteria)(params[1])];
                default:
                    const msg = error_1.ErrMsg.InvalidSubscriptionName(name);
                    throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
        };
        this._sendRawTransaction = (params) => {
            const raw = params[0];
            if (!(0, utils_1.isHexStrict)(raw)) {
                const msg = error_1.ErrMsg.ArgumentMissingOrInvalid('eth_sendRawTransaction', 'raw');
                throw new eip1193_1.ProviderRpcError(error_1.ErrCode.InvalidParams, msg);
            }
            return [raw];
        };
        this.outputReceiptFormatter = (receipt) => {
            const logs = (receipt.outputs.length > 0 && receipt.outputs[0].events.length > 0) ?
                receipt.outputs[0].events.map((event, index) => {
                    return {
                        blockHash: receipt.meta.blockID,
                        blockNumber: (0, utils_1.toHex)(receipt.meta.blockNumber),
                        transactionHash: receipt.meta.txID,
                        address: event.address,
                        topics: event.topics.map((x) => x),
                        data: event.data,
                        removed: false,
                        transactionIndex: receipt.transactionIndex,
                        logIndex: receipt.logInds[index],
                    };
                }) : [];
            return {
                status: !receipt.reverted ? '0x1' : '0x0',
                blockHash: receipt.meta.blockID,
                blockNumber: (0, utils_1.toHex)(receipt.meta.blockNumber),
                transactionHash: receipt.meta.txID,
                gasUsed: (0, utils_1.toHex)(receipt.gasUsed),
                transactionIndex: receipt.transactionIndex,
                from: receipt.from,
                to: receipt.to,
                cumulativeGasUsed: '0x0',
                logsBloom: common_1.zeroBytes256,
                contractAddress: (receipt.outputs.length && receipt.outputs[0].contractAddress) ? receipt.outputs[0].contractAddress : null,
                logs: logs,
            };
        };
        this.outputBlockFormatter = (b) => {
            return {
                hash: b.id,
                parentHash: b.parentID,
                number: (0, utils_1.toHex)(b.number),
                size: (0, utils_1.toHex)(b.size),
                stateRoot: b.stateRoot,
                receiptsRoot: b.receiptsRoot,
                transactionsRoot: b.txsRoot,
                timestamp: (0, utils_1.toHex)(b.timestamp),
                gasLimit: (0, utils_1.toHex)(b.gasLimit),
                gasUsed: (0, utils_1.toHex)(b.gasUsed),
                transactions: b.transactions,
                miner: b.signer,
                // incompatible fields
                difficulty: '0x0',
                totalDifficulty: '0x0',
                uncles: [],
                sha3Uncles: common_1.zeroBytes32,
                nonce: common_1.zeroBytes8,
                logsBloom: common_1.zeroBytes256,
                extraData: '0x',
            };
        };
        this.outputTransactionFormatter = (tx) => {
            return {
                hash: tx.id,
                blockNumber: (0, utils_1.toHex)(tx.meta.blockNumber),
                blockHash: tx.meta.blockID,
                from: tx.origin,
                to: tx.clauses[0].to,
                input: tx.clauses[0].data,
                value: tx.clauses[0].value,
                gas: (0, utils_1.toHex)(tx.gas),
                transactionIndex: tx.transactionIndex,
                // incompatible fields
                nonce: '0x0',
                gasPrice: '0x0'
            };
        };
        this.outputLogsFormatter = (ret) => {
            return ret.logs.map((log, i) => {
                return {
                    address: log.address,
                    topics: log.topics,
                    data: log.data,
                    blockHash: log.meta.blockID,
                    blockNumber: (0, utils_1.toHex)(log.meta.blockNumber),
                    transactionHash: log.meta.txID,
                    removed: false,
                    transactionIndex: ret.txInds[i],
                    logIndex: ret.logInds[i],
                };
            });
        };
        this.outputHeaderFormatter = (b) => {
            return {
                hash: b.id,
                parentHash: b.parentID,
                number: (0, utils_1.toHex)(b.number),
                stateRoot: b.stateRoot,
                receiptsRoot: b.receiptsRoot,
                transactionsRoot: b.txsRoot,
                timestamp: (0, utils_1.toHex)(b.timestamp),
                gasLimit: (0, utils_1.toHex)(b.gasLimit),
                gasUsed: (0, utils_1.toHex)(b.gasUsed),
                miner: b.signer,
                // incompatible fields
                sha3Uncles: common_1.zeroBytes32,
                nonce: common_1.zeroBytes8,
                logsBloom: common_1.zeroBytes256,
                extraData: '0x',
            };
        };
        this._connex = connex;
        this._ifSetNet = ifSetNet;
        this._inputFormatters['eth_getBlockByNumber'] = this._getBlockByNumber;
        this._inputFormatters['eth_getBlockByHash'] = this._getBlockByHash;
        this._inputFormatters['eth_getBalance'] = this._getBalance;
        this._inputFormatters['eth_getCode'] = this._getCode;
        this._inputFormatters['eth_getStorageAt'] = this._getStorageAt;
        this._inputFormatters['eth_sendTransaction'] = this._sendTransaction;
        this._inputFormatters['eth_call'] = this._call;
        this._inputFormatters['eth_estimateGas'] = this._estimateGas;
        this._inputFormatters['eth_getLogs'] = this._getLogs;
        this._inputFormatters['eth_subscribe'] = this._subscribe;
        this._inputFormatters['eth_sendRawTransaction'] = this._sendRawTransaction;
    }
}
exports.Formatter = Formatter;
//# sourceMappingURL=formatter.js.map